
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define LINE_LEN 512
#define DICT_WORD_LEN 128
#define DICT_WORD_COUNT (2 << 22)

// Remove the trailing newline
void clean(char *str) {
  int i = 0;

  char curr = str[i];
  while (curr != '\0') {
    if (curr == '\n') {
      str[i] = '\0';
    }

    curr = str[++i];
  }
}

// Get the index at which a character occurs for the nth time (if it does)
int nth_occurrence(char c, char *str, int n) {
  int i = 0;
  int occurred = 0;

  char curr = str[i];
  while (curr != '\0') {
    if (curr == c) {
      occurred++;
    }

    if (occurred == n) {
      return i;
    }

    curr = str[++i];
  }

  return -1;
}

int main(int argc, char **argv) {
  if (argc < 3) {
    printf("Incorrect number of arguments. Provide a passwd_path and "
           "shadow_path\n");
    return 1;
  }

  // Load all words of the dictionary in memory
  char *words = calloc(DICT_WORD_COUNT, DICT_WORD_LEN);
  char *plain_words = calloc(DICT_WORD_COUNT, DICT_WORD_LEN);
  // Read the gutenberg 24-letter combos
  FILE *gutenberg_24 = NULL;
  gutenberg_24 = fopen("unique-gutenberg.txt", "r");
  if (gutenberg_24 == NULL) {
    printf("Failed to open gutenberg dict");
    return 1;
  }

  int i = 0;
  char word_line[DICT_WORD_LEN];
  char *word_res = fgets(word_line, DICT_WORD_LEN, gutenberg_24);
  while (word_res != NULL && i < DICT_WORD_COUNT) {
    clean(word_line);

    // Hash
    // todo: replace with dynamic salt
    char *hashed = crypt(word_line, "$1$BT");

    // Copy the hashed word and the "normal" word to memory
    strncpy(&words[DICT_WORD_LEN * i], hashed, DICT_WORD_LEN);
    strncpy(&plain_words[DICT_WORD_LEN * i], word_line, DICT_WORD_LEN);
    // printf("Got word %s\n", &words[DICT_WORD_LEN * i]);

    if (i % 1000 == 0) {
      printf("Hashed %d words so far\n", i);
    }

    // Keep loopin
    word_res = fgets(word_line, DICT_WORD_LEN, gutenberg_24);
    i++;
  }
  fclose(gutenberg_24);
  int actual_count = i;
  printf("There were actually %d words in the wordlist\n", actual_count);

  char *passwd_path = argv[1];
  char *shadow_path = argv[2];

  // Open both files
  FILE *pswd = NULL;
  FILE *shdw = NULL;

  pswd = fopen(passwd_path, "r");
  shdw = fopen(shadow_path, "r");
  if (pswd == NULL || shdw == NULL) {
    printf("fopen failed\n");
    return 1;
  }

  char pswd_line[LINE_LEN];
  char shdw_line[LINE_LEN];

  // Read and execute on all lines one by one
  char *pswd_res = fgets(pswd_line, LINE_LEN, pswd);
  char *shdw_res = fgets(shdw_line, LINE_LEN, shdw);
  while (pswd_res != NULL && shdw_res != NULL) {
    int salt_start = nth_occurrence('$', shdw_res, 1);
    int salt_end = nth_occurrence('$', shdw_res, 3) + 1;
    int salt_len = salt_end - salt_start;

    char salt[salt_len + 1];
    strncpy(salt, &shdw_res[salt_start], salt_len);
    salt[salt_len] = '\0';

    // The complete hash, as needs to be compared to the one generated by
    // 'crypt'
    int hash_start = salt_start;
    int hash_end = nth_occurrence(':', shdw_res, 2);
    int hash_len = hash_end - hash_start;

    char hash[hash_len + 1];
    strncpy(hash, &shdw_res[hash_start], hash_len);
    hash[hash_len] = '\0';

    // The user is always at the start of the line
    int user_end = nth_occurrence(':', shdw_res, 1);
    int user_len = user_end;

    char user[user_len + 1];
    strncpy(user, &shdw_res[0], user_len);
    user[user_len] = '\0';

    // printf("Got user %s\nGot salt %s\nGot hash: %s\n----\n", user, salt,
    // hash);

    // Try all 24-letter hashes and print if it is a match
    for (int i = 0; i < actual_count; i++) {
      char *word = &words[DICT_WORD_LEN * i];
      if (strncmp(word, hash, hash_len) == 0) {
        char *plain_word = &plain_words[DICT_WORD_LEN * i];
        printf("%s:%s\n", user, plain_word);
        fflush(stdout);
        break;
      }
    }

    // Keep loopin
    pswd_res = fgets(pswd_line, LINE_LEN, pswd);
    shdw_res = fgets(shdw_line, LINE_LEN, shdw);
  }

  // Clean up
  fclose(pswd);
  fclose(shdw);

  return 0;
}