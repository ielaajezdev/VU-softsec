# notes
- can choose a `bondtype` beyond 3, so can set the bond type to any arbitrary number
- `molecule_change_atom` can overflow buffer, because no length is given
    - but this is on the heap, not on the stack
        - does not matter, bc we an overwrite the function pointer `print_info` in the struct with this, which we can call later
        - in the `atom` struct, this is 8 bytes (length of name) past the `name` field, so fill with 8 garbage bytes and then the address to jump to
- binary is statically linked, got is empty and libc is not dynamically loaded, no PIE so ropping is chill - no need to leak a pointer to defeat ASLR for gadget use
- can overwrite function pointer for `print_info` but need to make a stack pivot to actually continue from the ROP chain on the heap
    - found in `leave; ret` gadget
    - put this stack pivot in the symbol of the atom and put the actual rop chain in the new name of the molecule because this is where the stack pivot will return to
        - now we can execute gadgets in our ROP chain, need to do execve syscall since there is no `system()` library call
        - need to prepare registers for `execve`, problematic because the string "bin/sh" should be placed in memory, but bc libc is not dynamically loaded so it is not
            - need to insert this string into memory somewhere, use the `.data` section 
            - location is not affected by ASLR but need a `read` syscall for this to read from stdin to the data section
            - cannot set up two syscalls and prepare them properly, buffer is too small (128 bytes) and program fails, ROP chain is 8 bytes too large:  1 return address too many...
            - need to be creative in setting up registers for both syscalls
                - instead of changing the first atom (index 0), change a later atom (used index 3), because $rdx is set to the index in the show_info loop, $rdx is used for the read syscall so this removes the need to set rdx manually (rdx specifies how many bytes will be read from stdin)
                - but the loop also sets $rax to a non-zero value then, but rax needs to be 0 to specify the read call, use the `mov rax, rdi; ret` gadget (0x0000000000422dd4) found with ropper to clear rax to 0 again. Saves 8 bytes over adding a `pop rax; ret` gadget to the chain
                - the chain is still too long, saw using GDB that the first 8 bytes of the payload became rbp, found a `mov rsi, rbp; syscall; ` gadget (0x000000000049b8fe:) using ropper. Set rbp to 0 in the payload and then use this gadget to initialize rsi and do a syscall immediately after. Saves two return addresses in the ROP chain! No longer need to do a `pop rsi; ret` and can save the 8 0-bytes then as well. There is no need to return after the syscall anyway
                - added some garbage bytes after the last return address in the chain, otherwise the last return address would have a 0-byte in it that would break it
- this now works: the first read will read the path to execve and then saves it in the .data section, the pointer in the data section is then used to `execve`. Used pwntools to send a null-terminated string to stdin, otherwise it would become "bin/sh\n", which is not a valid path (and the execve syscall would fail)

- this level was more difficult than level 8 imo...