# prep
- compiled binary to my home dir as `7AAAAAAA` so that the environment (containing the binary path) is exactly the same length as the real binary (i.e. len `/var/challenge/level7/7` == len `/home/iel44jez/7AAAAAAA`) so that memory layout/stack locations are the same in GDB as for the real binary
- created a `pwntools` template
- used `x/4s *((char **)environ)` in GDB to see where my shellcode is located
- used GDB with `info frame` to see where the return address is stored (to overwrite)

# exploit notes
- stepping through the program with GDB reveals that some values are not at the stack but in registers that we control with the input we send to the inline assembly, this is due to the optimizations applied during compilation (`-O1` flag)
- tasks:
    - need to first modify the uid, so that an arbitrary function pointer is executed
    - need to set the function pointer to some shellcode
    - need to set %r13d to 53, and need to set %r14 to the callback location
        - this is done due to optimizations, that is why r14 is not on the stack
- rules to make the exploit work:
    - subtract enough from $0x8000000abcde to become the return address
    - let the last number of this subtraction be ASCII 5
    - shellcode is at 0x7fffffffeec8 + 50
    - need to subtract 0xacde4